--
--CREATE TABLE CHECK_OUT (
--    BOOK_ID NUMBER NOT NULL,
--    USER_ID VARCHAR2(20) NOT NULL,
--    STATE VARCHAR2(20) NOT NULL,
--    CHECK_OUT_DATE DATE NOT NULL,
--    CHECK_IN_DATE DATE NOT NULL
--);
--
--ALTER TABLE CHECK_OUT ADD CONSTRAINT PK PRIMARY KEY(BOOK_ID);
--ALTER TABLE CHECK_OUT ADD CONSTRAINT FK1 
--FOREIGN KEY (USER_ID) REFERENCES USER_INFO(USER_ID);


--CREATE TRIGGER STATE_RESERVED_TRIGGER
--AFTER INSERT ON CHECK_OUT
--FOR EACH ROW
--BEGIN
--    UPDATE BOOK
--    SET BOOK.STATE = :NEW.STATE
--    WHERE BOOK.BOOK_ID = :NEW.BOOK_ID;
--END;
--COMMIT;


--CREATE TRIGGER STATE_DELETE_TRIGGER
--AFTER DELETE ON CHECK_OUT
--FOR EACH ROW
--BEGIN
--    UPDATE BOOK
--    SET STATE = 'SET'
--    WHERE BOOK_ID = :OLD.BOOK_ID;
--END;
--ALTER TABLE CHECK_OUT
--ADD CONSTRAINT PK PRIMARY KEY (BOOK_ID, STATE);

--SELECT TRIGGER_NAME, TABLE_NAME, TRIGGER_TYPE, TRIGGER_BODY
--FROM ALL_TRIGGERS
--WHERE TABLE_NAME = 'CHECK_OUT';


--SELECT C.BOOK_ID, B.STATE, C.CHECK_OUT_DATE, C.CHECK_IN_DATE, 
--B.NAME, B.WRITER, B.CATEGORY, C.STATE, B.IMAGE FROM CHECK_OUT C JOIN BOOK B ON C.BOOK_ID = B.BOOK_ID;
--
--CREATE TABLE BLACK_LIST (
--    USER_ID VARCHAR(20) PRIMARY KEY,
--    BAN_DATE DATE NOT NULL,
--    RELEASE_DATE DATE NOT NULL
--);

--BEGIN
--DBMS_SCHEDULER.CREATE_JOB (
--    JOB_NAME => 'TEST',
--    JOB_TYPE => 'PLSQL_BLOCK',
--    JOB_ACTION => 'BEGIN
--        ;
--        END;',
--    START_DATE => SYSTIMESTAMP,
--    REPEAT_INTERVAL => 'FREQ=SECONDLY;INTERVAL=10',
--    ENABLE => TRUE
--);
--END;
CREATE SEQUENCE POST_ID_SEQ 
    START WITH 1
    NOCACHE
    NOCYCLE;


CREATE TABLE POST (
    POST_ID NUMBER PRIMARY KEY,
    POST_TITLE VARCHAR2(30),
    POST_CONTENT VARCHAR2(200),
    USER_ID VARCHAR2(20),
    TAG VARCHAR2(20),
    VIEWS NUMBER,
    WRITE_DATE DATE,
    CONSTRAINT UID_REF FOREIGN KEY (USER_ID) REFERENCES USER_INFO(USER_ID)
);

CREATE SEQUENCE REPLY_ID_SEQ 
    START WITH 1
    NOCACHE
    NOCYCLE;
    
CREATE TABLE REPLY (
    REPLY_ID NUMBER PRIMARY KEY,
    POST_ID NUMBER,
    USER_ID VARCHAR(20),
    REPLY_CONTENT VARCHAR(30),
    WRITE_DATE DATE,
    CONSTRAINT PID_REF FOREIGN KEY (POST_ID) REFERENCES POST(POST_ID) ON DELETE CASCADE,
    CONSTRAINT UID_REPLY_REF FOREIGN KEY (USER_ID) REFERENCES USER_INFO(USER_ID)
);

INSERT INTO POST 
VALUES (
    POST_ID_SEQ.NEXTVAL,
    'TEST7',
    'TEST7TEST7',
    'Guest',
    '공지사항',
    0,
    sysdate
);

select * from (
	select post.*, row_number() over (order by WRITE_DATE desc) AS RN
    from post WHERE POST_ID = 1
) 
where RN between 1 and 2;
COMMIT;

-- 연체 중인 도서 목록
SELECT * FROM CHECK_OUT
WHERE STATE = 'OUT' AND CHECK_IN_DATE < SYSDATE;

-- 차단된 유저 목록
SELECT * FROM BLACK_LIST;

-- 유저 수
SELECT COUNT(*) FROM USER_INFO;

CREATE TABLE SEAT (
    SEAT_ID NUMBER PRIMARY KEY, 
    POSITION_X NUMBER NOT NULL,
    POSITION_Y NUMBER NOT NULL,
    USER_ID VARCHAR2(20),
    START_TIME DATE,
    END_TIME DATE,
    STATE VARCHAR2(10) DEFAULT 'EMPTY',
    CONSTRAINT USER_ID FOREIGN KEY (USER_ID) REFERENCES USER_INFO(USER_ID) ON DELETE CASCADE
);
CREATE TABLE SEAT (
    SEAT_ID VARCHAR2(20) PRIMARY KEY, 
    POSITION_X NUMBER NOT NULL,
    POSITION_Y NUMBER NOT NULL,
    USER_ID VARCHAR2(20),
    START_TIME DATE,
    END_TIME DATE,
    STATE VARCHAR2(10) DEFAULT 'EMPTY',
    CONSTRAINT USER_ID FOREIGN KEY (USER_ID) REFERENCES USER_INFO(USER_ID) ON DELETE CASCADE
);

UPDATE CHECK_OUT
SET CHECK_OUT_DATE = '2024/03/01', CHECK_IN_DATE = '2024/03/08'
WHERE USER_ID = 'blacklist';
COMMIT;

INSERT INTO BLACK_LIST
VALUES ('Release', '2024/03/01', '2024/03/08');
COMMIT;
SELECT * FROM ( SELECT BOOK.*, ROW_NUMBER() OVER (ORDER BY BOOK_ID DESC) AS RN 
FROM BOOK WHERE NAME LIKE '%불%' ORDER BY BOOK_ID DESC) WHERE RN BETWEEN 1 AND 10;

--SELECT BOOK.NAME, BC.* FROM BOOK JOIN (
--SELECT B.USER_ID, C.BOOK_ID, C.CHECK_IN_DATE FROM BLACK_LIST B JOIN CHECK_OUT C
--ON B.USER_ID = C.USER_ID WHERE C.CHECK_IN_DATE < SYSDATE
--) BC
--ON BOOK.BOOK_ID = BC.BOOK_ID
--ORDER BY BC.CHECK_IN_DATE;
--INSERT INTO CHECK_OUT 
--VALUES (3, 'Release', 'OUT', '2024/03/15', '2024/03/30');

SELECT BC.*, U.NAME, U.PHONE, U.EMAIL
FROM (
SELECT B.BOOK_ID, B.NAME, C.USER_ID, C.CHECK_IN_DATE
FROM BOOK B JOIN CHECK_OUT C
ON B.BOOK_ID = C.BOOK_ID
WHERE C.CHECK_IN_DATE < SYSDATE
) BC JOIN USER_INFO U
ON BC.USER_ID = U.USER_ID
ORDER BY BC.CHECK_IN_DATE;

commit;

SELECT BC.*, U.NAME, U.PHONE, U.EMAIL
FROM (
SELECT B.BOOK_ID, B.NAME, C.USER_ID, C.CHECK_IN_DATE
FROM BOOK B JOIN CHECK_OUT C
ON B.BOOK_ID = C.BOOK_ID
WHERE C.CHECK_IN_DATE < SYSDATE
) BC JOIN USER_INFO U
ON BC.USER_ID = U.USER_ID
ORDER BY BC.CHECK_IN_DATE;

DELETE CHECK_OUT WHERE BOOK_ID = 3;
COMMIT;

